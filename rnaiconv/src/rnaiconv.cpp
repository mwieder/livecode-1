///////////////////////////////////////////////////////////////////////////////
//
// Revolution external main entry point for 'rnaiconv'
//
// Generated by External Creator V1.00
//
// For language: C++ (no exceptions, no rtti)
//

#include <revolution/external.h>

///////////////////////////////////////////////////////////////////////////////
//
// BEGIN USER DEFINITIONS
#include <cstdlib>
#include <cstring>
#include <cerrno>
#include <iconv.h>

// Function:
// rnaIconv pSrcEncoding, pDstEncoding, pNameOfInTextVar, pNameOfOutTextVar
// Parameters:
// pSrcEncoding - the name of the source encoding
// pDstEncoding - the name of the destination encoding
// pNameOfInTextVar - the name of the variable containing the text we want
// to convert
// pNameOfOutTextVar - the name of the variable containing the text we want
// to place the converted text into
void rnaIconv(char *p_arguments[], int p_argument_count, char **r_result, Bool *r_pass, Bool *r_err) {
   int t_success;
   // First check we have been passed 4 arguments and throw a (Revolution)
   // exception if not.
   if (p_argument_count != 4) {
      *r_result = strdup("wrong number of parameters");
      *r_err = True;
      *r_pass = False;
      return;
   }
  // Next we attempt to fetch the source text data we wish to use.
  // To do this we use the 'GetVariableEx' call from the Externals API
  ExternalString t_src_text;
  GetVariableEx(p_arguments[2], "", &t_src_text, &t_success);
  if (t_success == EXTERNAL_FAILURE) {
     *r_result = strdup("unknown input variable");
     *r_err = True;
     *r_pass = False;
     return;
     }
  // Next attempt to create an iconv converter object using the given
  // source and destination encodings.
  // If creation fails, we throw a (Revolution) exception.
  iconv_t t_converter;
  t_converter = iconv_open(p_arguments[1], p_arguments[0]);
  if (t_converter == NULL) {
     *r_result = strdup("unable to create converter");
     *r_err = True;
     *r_pass = False;
     return;
     }
  // We now convert the source text we have into an output buffer
  // that we extend as appropriate.
  // iconv works by attempting to convert as much input as possible
  // into an output buffer of a given size, therefore we loop,
  // extending the buffer on each iteration until no input remains.
  // At each iteration, we allocate twice the remaining input size
  // which should be fine for most encoding conversions.
  // If the variable is unknown, throw an error.
  // As the iconv call modifies the input buffer and length parameters
  // we make copies here.
  char *t_in_text_ptr;
  size_t t_in_text_left;
  t_in_text_ptr = (char *)t_src_text . buffer;
  t_in_text_left = t_src_text . length;
  // Setup initial values for the out text buffer. These initial values
  // are 0/NULL since the first thing we do in the loop is allocate
  // memory for that iteration.
  char *t_out_text_base;
  size_t t_out_text_frontier;
  size_t t_out_text_limit;
  t_out_text_base = NULL;
  t_out_text_frontier = 0;
  t_out_text_limit = 0;
  // Flags that indicate what error occured (if any)
  bool t_memory_error;
  t_memory_error = false;
  bool t_conversion_error;
  t_conversion_error = false;
  while(t_in_text_left != 0) {
     // Extend our output buffer.
     char *t_new_out_text_base;
     t_new_out_text_base = (char *)realloc(t_out_text_base, t_out_text_limit + t_in_text_left * 2);
     if (t_new_out_text_base == NULL) {
        t_memory_error = true;
        break;
        }
     t_out_text_limit += t_in_text_left * 2;
     t_out_text_base = t_new_out_text_base;
     // Compute start pointer and bytes remaining for the out text buffer
     char *t_out_text_ptr;
     t_out_text_ptr = t_out_text_base + t_out_text_frontier;
     size_t t_out_text_left;
     t_out_text_left = t_out_text_limit - t_out_text_frontier;
     // Attempt the conversion
     size_t t_iconv_result;
     t_iconv_result = iconv(t_converter, &t_in_text_ptr, &t_in_text_left, &t_out_text_ptr, &t_out_text_left);
     if (t_iconv_result == (size_t)(-1) && errno != E2BIG) {
        t_conversion_error = true;
        break;
        }
     // Update the output buffer's frontier (i.e. increase by the number
     // of bytes newly converte).
     t_out_text_frontier += (t_out_text_limit - t_out_text_frontier) - t_out_text_left;
     }
     if (t_memory_error) {
        // If a memory error occured, throw an error.
        *r_result = strdup("out of memory");
        *r_pass = False;
        *r_err = True;
        } else if (t_conversion_error) {
        // If a conversion error occured, throw an error.
        *r_result = strdup("conversion error");
        *r_pass = False;
        *r_err = True;
        } else {
        // No errors occured during conversion so attempt to write out result
        // into the output variable
        ExternalString t_out_text;
        t_out_text . buffer = t_out_text_base;
        t_out_text . length = t_out_text_frontier;
        SetVariableEx(p_arguments[3], "", &t_out_text, &t_success);
        // If the variable is unknown, throw an error.
        if (t_success == EXTERNAL_FAILURE) {
           *r_result = strdup("unknown output variable");
           *r_pass = False;
           *r_err = True;
           } else {
           *r_result = strdup("");
           *r_pass = False;
           *r_err = False;
           }
        }
     // Deallocate our out text buffer
     free(t_out_text_base);
     // Close the iconv converter
     iconv_close(t_converter);
     }

// END USER DEFINITIONS
//
///////////////////////////////////////////////////////////////////////////////


EXTERNAL_BEGIN_DECLARATIONS("rnaiconv")

// BEGIN USER DECLARATIONS
EXTERNAL_DECLARE_COMMAND("rnaiconv", rnaIconv)
// END USER DECLARATIONS

EXTERNAL_END_DECLARATIONS
